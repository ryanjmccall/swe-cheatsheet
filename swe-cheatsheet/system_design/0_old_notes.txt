SDI

READ HDB

1. Requirements clarification
- functionality and performance
2. API definition (system interface)
3. Estimation
- scale (actions per sec, DAU), storage (***how to do***), bandwidth (***how to do***)
4. Data Model
5. High-level design
6. Detailed design (with pro's / con's)
7. Identify and resolve bottlenecks

__Elements__

Cache, CAP, ConsisHash, HTTP, Idx, LB, Proxies, Qs, Redund&Repl, Sql/NoSql, Sharding

ajax, long poll, sockets, sse's

1. Load Balancer
 - b/w user and web server
 - b/w web server and app or cache servers
 - b/w platform and database

Client -> [LB] -> Web Server -> [LB] -> App Server -> [LB] -> DB
client <Load balancer> web server <load balancer> app server <load balancer> db

- Types 1) smart clients applications, 2) hardware LBs, 3) software LBs HAProxy
- Method: least connections, least response time, least bandwidth, RR, weighted RR
- Redudant Load Balancers, monitor each other
- Smart LBs offer predictive analytics

2. Caching
 - too many requests, db too slow
  - App server cache, works for small number of nodes, but then cache missing increase
  - Distributed cache, sharded by consistent hashing, how to handle missing nodes?
  - Global cache, every goes to a fast piece of hardware, either cache retrieves misses OR requesters retrieve misses (good when files are large or cache's elements must be static)
  - CDN for large amount of static media

 - Invalidation, write-through, write-around, write-back
-- write-through, cache and DB
-- write-around, DB only
-- write-back, cache only, periodically write to DB

 - Eviction, FIFO, LIFO, LRU, MRU, LFU, RR
 -- TTL cache, first in first out, least recently used

3. Sharding / Partitioning
- too much data
- partitioning - split by rows on single schema, sharding split across multiple machines
- splitting: horizontal, vertical, directory-based
- assignment: hash, list, RR, combo
- problems:
-- joins slow and denormalized tables inconsistent
-- referencial integrity / FKs breaks; requires app code or cleanup SQL
-- rebalancing, can solved with replicated directory-based partitioning

4. Indexes: speeds read queries, slows other ops

5. Proxies: filters, collapse forwarding

6. Queues: asynchrony decouples indeterminate processing like writes

7. Redundancy (failover) and replication (duplication)

8. SQL vs. NoSQL
- SQL: ACID & structured
- NoSQL: Large volume, cloud computing, rapid development
- NoSQL types: Key-Value stores, Document db, Wide-Column, Graph database

9. CAP - choose availability (always functional) or consistency (all users see same data) under network failure

10. Consistent hashing - assign nodes to a bucket of integers in modular space, can also split these buckets evenly across the modular space so hash function mixes well; minimizes key-to-server remaps when adding or removing a node

11. HTTP - AJAX polling back-and-forth, long-poll client waits on hold, websockets duplex, SSEs once to server, many to client

Key characteristics of Distributed Systems - REMS
- Reliability
- Efficiency (response time / throughput; # messages sent & message size)
- Manageability
- Scalability

